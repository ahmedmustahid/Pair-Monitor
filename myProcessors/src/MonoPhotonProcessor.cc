#include "MonoPhotonProcessor.h"
#include <iostream>

#include <EVENT/LCCollection.h>
#include <EVENT/ReconstructedParticle.h>
#include <EVENT/MCParticle.h>
#include <EVENT/SimCalorimeterHit.h>


// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"

#ifdef MARLIN_USE_AIDA
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>

//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

#include "TFile.h"
#include "TTree.h"
#include "TMath.h"
#include "TVector3.h"

using namespace lcio ;
using namespace marlin ;


MonoPhotonProcessor aMonoPhotonProcessor ;


MonoPhotonProcessor::MonoPhotonProcessor() : Processor("MonoPhotonProcessor") {

    // modify processor description
    _description = "MonoPhotonProcessor does whatever it does ..." ;


    // register steering parameters: name, description, class-variable, default value
    registerInputCollection( LCIO::MCPARTICLE,
            "MCParticle" , 
            "Name of the MCParticle collection"  ,
            _colMCP ,
            std::string("MCParticle")
    );
    //BeamCalorimeterHit
    registerInputCollection( LCIO::SIMCALORIMETERHIT,
  	   "BeamCalCollection" , 
  	   "Name of the BeamCalHits collection"  ,
  	   _colBeamCal ,
  	   std::string("BeamCalCollection") 
    ) ;

/*
    registerInputCollection( LCIO::LCRELATION,
	   "InputMCTruthLinkCollection" , 
  	   "Name of the MCTruthLink collection"  ,
  	   _colMCBeamCalRelation ,
  	   std::string("RecoMCTruthLink") 
    ) ;
*/
    registerProcessorParameter( "OutputRootFileName",
           "Name of Root file (default: output.root)",
           _rootfilename, 
           std::string("output.root")
    );

}



void MonoPhotonProcessor::init() { 

    streamlog_out(DEBUG) << "   init called  " << std::endl ;

    std::cout<<"inside init"<<std::endl;

    // usually a good idea to
    printParameters() ;

    _nRun = 0 ;
    _nEvt = 0 ;

//    _navBeamCal = 0;

    makeNTuple();

}


void MonoPhotonProcessor::processRunHeader( LCRunHeader* run) { 
    
    std::cout<<"inside RunHeader"<<std::endl;
    _nRun++ ;
} 



void MonoPhotonProcessor::processEvent( LCEvent * evt ) { 

    // this gets called for every event 
    // usually the working horse ...

    // Clear memory
    memset( &_data, 0, sizeof(_data) );

    // try to get lcio collection (exits if collection is not available)
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    LCCollection* colmcp = evt->getCollection( _colMCP ) ;
    LCCollection* colBeamCal = evt->getCollection( _colBeamCal ) ;
//    LCCollection* colmcBeamCalrel = evt->getCollection( _colMCBeamCalRelation ) ;

    std::cout<<"inside process event"<<std::endl;
    // Alternativelly if you do not want Marlin to exit in case of a non-existing collection
    // use the following (commented out) code:
    LCCollection* col = NULL;
    try{
        col = evt->getCollection( _colMCP );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colMCP << " collection not available" << std::endl;
        col = NULL;
    }
   
    
    LCCollection* col1 = NULL;
    try{
        col1 = evt->getCollection( _colBeamCal );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colBeamCal << " collection not available" << std::endl;
        col1 = NULL;
    }
    

    // this will only be entered if the collection is available
    if( colmcp != NULL ){

        int nMCP = colmcp->getNumberOfElements()  ;
        _data.nmcps = nMCP;

        if (nMCP>0) {
          MCParticle* beam = dynamic_cast<MCParticle*>( colmcp->getElementAt( 0 ) ) ;
          _data.ipx = getIP(beam).X(); 
          _data.ipy = getIP(beam).Y(); 
          _data.ipz = getIP(beam).Z(); 
        }

        // create MCParticle pointer and indices in MCParticle collection
        std::map<MCParticle*,int> mcpmap;
        for(int i=0; i< nMCP ; i++){
           MCParticle* p = dynamic_cast<MCParticle*>( colmcp->getElementAt( i ) ) ;
           mcpmap.insert(std::map<MCParticle*,int>::value_type(p,i));
        }
        //std::cout<<"nMCP "<<nMCP<<std::endl;
        for(int i=0; i< nMCP ; i++){
            //std::cout << "i = " << i << std::endl;

            MCParticle* p = dynamic_cast<MCParticle*>( colmcp->getElementAt( i ) ) ;

            //std::cout<<"MCP pointers p "<<p<<std::endl;

            // keep index. useful to compare with outputs of dumpevent.
            _data.mcp_index[i] = i;

            // keep parents info
            _data.mcp_nparents[i] = int(p->getParents().size());
            for (int j = 0; j < p->getParents().size(); j++) {
              _data.mcp_parentIndex[i][j] = mcpmap.find(p->getParents()[j])->second;
            }

            // keep daughters info
            _data.mcp_ndaughters[i] = int(p->getDaughters().size());
            for (int j = 0; j < p->getDaughters().size(); j++) {
              _data.mcp_daughterIndex[i][j] = mcpmap.find(p->getDaughters()[j])->second;
            }

            _data.mcp_e[i]     = p->getEnergy(); 
            float px = p->getMomentum()[0];
            float py = p->getMomentum()[1];
            float pz = p->getMomentum()[2];
            _data.mcp_px[i]    = px;
            _data.mcp_py[i]    = py;
            _data.mcp_pz[i]    = pz; 

            TVector3 pv(px,py,pz);
            _data.mcp_phi[i]   = pv.Phi(); 
            //_data.mcp_theta[i] = pv.Theta(); // need to consider 2pi = 0.
            _data.mcp_theta[i] = TMath::ATan(pv.Perp()/pz);
            _data.mcp_chrg[i]  = p->getCharge();
            _data.mcp_startx[i] = float(p->getVertex()[0]);
            _data.mcp_starty[i] = float(p->getVertex()[1]);
            _data.mcp_startz[i] = float(p->getVertex()[2]);
            _data.mcp_endx[i]   = float(p->getEndpoint()[0]);
            _data.mcp_endy[i]   = float(p->getEndpoint()[1]);
            _data.mcp_endz[i]   = float(p->getEndpoint()[2]);
            _data.mcp_pdg[i]   = p->getPDG();
            _data.mcp_genstatus[i] = p->getGeneratorStatus();
            _data.mcp_simstatus[i] = p->getSimulatorStatus();
            _data.mcp_iscreatedinsim[i] = p->isCreatedInSimulation();
            

            //std::cout<<"assigned all vars"<<std::endl;

        } 
        std::cout<<"outside loop"<<std::endl;
    }
    if( colBeamCal != NULL ){

        int nBeamCal = colBeamCal->getNumberOfElements()  ;
        _data.nBeamCals = nBeamCal;

        std::cout<<"nBeamCal "<<nBeamCal<<std::endl;

        //if( colmcBeamCalrel != NULL ) _navBeamCal = new LCRelationNavigator( colmcBeamCalrel );

        int icalhits = 0;
        for(int i=0; i< nBeamCal ; i++){
            SimCalorimeterHit* p = dynamic_cast<SimCalorimeterHit*>( colBeamCal->getElementAt( i ) ) ;
            //BeamCalCollection* p = dynamic_cast<BeamCalCollection*>( colBeamCal->getElementAt( i ) ) ;
            //ReconstructedParticle* p = dynamic_cast<ReconstructedParticle*>( colBeamCal->getElementAt( i ) ) ;
            std::cout<<"BeamCal pointer "<<p<<std::endl;
            std::cout<<"BeamCal i "<<i<<std::endl;
            // TRK info
            //const EVENT::TrackVec & trkvec = p->getTracks();
            // CAL info
            //const EVENT::ClusterVec& clusvec = p->getClusters();

/*            // MC Relation
            MCParticle* mcr = 0;
            if (_navBeamCal) {
              //int nmcr = _navBeamCal->getRelatedToWeights( p ).size();
              int nmcr = _navBeamCal->getRelatedToObjects( p ).size();
              _data.nmcr[i] = nmcr; 
              if ( nmcr > 0 ) {
                 mcr = dynamic_cast< MCParticle *> ( _navBeamCal->getRelatedToObjects( p )[0] );
                 _data.mcr_weight[i] = _navBeamCal->getRelatedToWeights( p )[0];
                 _data.mcr_e[i]     = mcr->getEnergy(); 
                 float px = mcr->getMomentum()[0];
                 float py = mcr->getMomentum()[1];
                 float pz = mcr->getMomentum()[2];
                 _data.mcr_px[i]    = px;
                 _data.mcr_py[i]    = py;
                 _data.mcr_pz[i]    = pz; 
                 TVector3 pv(px,py,pz);
                 _data.mcr_phi[i]   = pv.Phi(); 
                 //_data.mcr_theta[i] = pv.Theta(); // need to consider 2pi = 0.
                 _data.mcr_theta[i] = TMath::ATan(pv.Perp()/pz); 
                 _data.mcr_chrg[i]  = mcr->getCharge();
                 _data.mcr_pdg[i]   = mcr->getPDG();
                 _data.mcr_genstatus[i] = mcr->getGeneratorStatus();
                 _data.mcr_simstatus[i] = mcr->getSimulatorStatus();
                 _data.mcr_iscreatedinsim[i] = mcr->isCreatedInSimulation();
              }
              delete _navBeamCal;
              _navBeamCal = 0;
            }
*/

            _data.BeamCal_e[i]     = p->getEnergy(); 
            _data.BeamCal_x[i]    = p->getPosition()[0];
            _data.BeamCal_y[i]    = p->getPosition()[1];
            _data.BeamCal_z[i]    = p->getPosition()[2];
            
            /*
            //float px = p->getMomentum()[0];
            //float py = p->getMomentum()[1];
            //float pz = p->getMomentum()[2];
            _data.BeamCal_px[i]    = px;
            _data.BeamCal_py[i]    = py;
            _data.BeamCal_pz[i]    = pz; 
            TVector3 pv(px,py,pz);
            _data.BeamCal_phi[i]   = pv.Phi(); 
            //_data.BeamCal_theta[i] = pv.Theta(); // need to consider 2pi = 0.
            _data.BeamCal_theta[i] = TMath::ATan(pv.Perp()/pz); 
            _data.BeamCal_chrg[i]  = p->getCharge();
            _data.BeamCal_pdg[i]   = p->getType();

            std::cout<<"inside BeamCal completion "<<std::endl;
        
            // fill first track info
            _data.BeamCal_ntrk[i]  = trkvec.size();
            if (trkvec.size()>0) {
                std::cout<<"inside trk.vec"<<std::endl;
              const Track* trk = trkvec[0];
              _data.BeamCal_d0[i] = trk->getD0();
              _data.BeamCal_z0[i] = trk->getZ0();
              _data.BeamCal_trkphi[i] = trk->getPhi();
              _data.BeamCal_omega[i] = trk->getOmega();
              _data.BeamCal_tanlambda[i] = trk->getTanLambda();
              _data.BeamCal_d0sig[i] = trk->getD0()/sqrt(trk->getCovMatrix()[0]);
              _data.BeamCal_z0sig[i] = trk->getZ0()/sqrt(trk->getCovMatrix()[9]);
            }

            // fill sum of cluster info
            int nclrs = clusvec.size();
            _data.BeamCal_nclus[i] = nclrs;

            if (clusvec.size()>0) {
              float xsum = 0.;
              float ysum = 0.;
              float zsum = 0.;
              for ( ClusterVec::const_iterator iCluster=clusvec.begin();
                    iCluster!=clusvec.end(); ++iCluster) {
                const Cluster* cls = *iCluster;
                const float* xp = cls->getPosition();
                xsum += xp[0]; 
                ysum += xp[1];
                zsum += xp[2]; 
                _data.BeamCal_ecal_e[i]  += cls->getSubdetectorEnergies()[0];
                _data.BeamCal_hcal_e[i]  += cls->getSubdetectorEnergies()[1];
                _data.BeamCal_yoke_e[i]  += cls->getSubdetectorEnergies()[2];
                _data.BeamCal_lcal_e[i]  += cls->getSubdetectorEnergies()[3];
                _data.BeamCal_lhcal_e[i] += cls->getSubdetectorEnergies()[4];
                _data.BeamCal_bcal_e[i]  += cls->getSubdetectorEnergies()[5];

                // Note that there is no hit info in DST files.
                const EVENT::CalorimeterHitVec & calhits = cls->getCalorimeterHits();
                for ( CalorimeterHitVec::const_iterator iCalhit=calhits.begin();
                    iCalhit!=calhits.end(); ++iCalhit) {
                  const CalorimeterHit* calhit = *iCalhit;
                  const float* xp = calhit->getPosition();
                  _data.clr_x[icalhits] = xp[0];
                  _data.clr_y[icalhits] = xp[1];
                  _data.clr_z[icalhits] = xp[2];
                  icalhits++;
                }
              }
              _data.BeamCal_cal_x[i] = xsum / nclrs;
              _data.BeamCal_cal_y[i] = ysum / nclrs;
              _data.BeamCal_cal_z[i] = zsum / nclrs;
            }
            */
        }
        _data.nclrhits = icalhits;
    }
    //-- note: this will not be printed if compiled w/o MARLINDEBUG=1 !

    streamlog_out(DEBUG) << "   processing event: " << evt->getEventNumber() 
        << "   in run:  " << evt->getRunNumber() << std::endl ;


    _data.evt = _nEvt;

    _evtdata->Fill(); 

    _nEvt ++ ;
}



void MonoPhotonProcessor::check( LCEvent * evt ) { 
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void MonoPhotonProcessor::end(){ 

       _otfile->Write();

     std::cout << "MonoPhotonProcessor::end()  " << name() 
      << " processed " << _nEvt << " events in " << _nRun << " runs "
         << std::endl ;

}

void MonoPhotonProcessor::makeNTuple() {

  // Output root file
  _otfile    = new TFile( _rootfilename.c_str() , "RECREATE" );

  EVTFILLDATA &d = _data;

  /** Define root tree
  */
  _evtdata  = new TTree( "evtdata" , "events" );
  _evtdata->Branch( "evt"             , &d.evt             , "evt/I"           );
  _evtdata->Branch( "nBeamCals"           , &d.nBeamCals           , "nBeamCals/I"         );
  _evtdata->Branch( "BeamCal_e"           , &d.BeamCal_e           , "BeamCal_e[nBeamCals]"          );
  _evtdata->Branch( "BeamCal_x"          , &d.BeamCal_x          , "BeamCal_x[nBeamCals]"         );
  _evtdata->Branch( "BeamCal_y"          , &d.BeamCal_y          , "BeamCal_y[nBeamCalcals]"         );
  _evtdata->Branch( "BeamCal_z"          , &d.BeamCal_z          , "BeamCal_z[nBeamCals]"         );
  /*
  _evtdata->Branch( "BeamCal_py"          , &d.BeamCal_py          , "BeamCal_py[nBeamCals]"         );
  _evtdata->Branch( "BeamCal_pz"          , &d.BeamCal_pz          , "BeamCal_pz[nBeamCals]"         );
  _evtdata->Branch( "BeamCal_phi"         , &d.BeamCal_phi         , "BeamCal_phi[nBeamCals]"        );
  _evtdata->Branch( "BeamCal_theta"       , &d.BeamCal_theta       , "BeamCal_theta[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_chrg"        , &d.BeamCal_chrg        , "BeamCal_chrg[nBeamCals]"       );
  _evtdata->Branch( "BeamCal_pdg"         , &d.BeamCal_pdg         , "BeamCal_pdg[nBeamCals]/I"      );
  _evtdata->Branch( "BeamCal_ntrk"        , &d.BeamCal_ntrk        , "BeamCal_ntrk[nBeamCals]/I"     );
  _evtdata->Branch( "BeamCal_d0"          , &d.BeamCal_d0          , "BeamCal_d0[nBeamCals]"         );
  _evtdata->Branch( "BeamCal_d0sig"       , &d.BeamCal_d0sig       , "BeamCal_d0sig[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_z0"          , &d.BeamCal_z0          , "BeamCal_z0[nBeamCals]"         );
  _evtdata->Branch( "BeamCal_z0sig"       , &d.BeamCal_z0sig       , "BeamCal_z0sig[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_trkphi"      , &d.BeamCal_trkphi      , "BeamCal_trkphi[nBeamCals]"     );
  _evtdata->Branch( "BeamCal_omega"       , &d.BeamCal_omega       , "BeamCal_omega[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_tanlambda"   , &d.BeamCal_tanlambda   , "BeamCal_tanlambda[nBeamCals]"  );
  _evtdata->Branch( "BeamCal_nclus"       , &d.BeamCal_nclus       , "BeamCal_nclus[nBeamCals]/I"    );
  _evtdata->Branch( "BeamCal_cal_x"       , &d.BeamCal_cal_x       , "BeamCal_cal_x[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_cal_y"       , &d.BeamCal_cal_y       , "BeamCal_cal_y[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_cal_z"       , &d.BeamCal_cal_z       , "BeamCal_cal_z[nBeamCals]"      );
  _evtdata->Branch( "BeamCal_ecal_e"      , &d.BeamCal_ecal_e      , "BeamCal_ecal_e[nBeamCals]"     );
  _evtdata->Branch( "BeamCal_hcal_e"      , &d.BeamCal_hcal_e      , "BeamCal_hcal_e[nBeamCals]"     );
  _evtdata->Branch( "BeamCal_yoke_e"      , &d.BeamCal_yoke_e      , "BeamCal_yoke_e[nBeamCals]"     );
  _evtdata->Branch( "BeamCal_lcal_e"      , &d.BeamCal_lcal_e      , "BeamCal_lcal_e[nBeamCals]"     );
  _evtdata->Branch( "BeamCal_lhcal_e"     , &d.BeamCal_lhcal_e     , "BeamCal_lhcal_e[nBeamCals]"    );
  _evtdata->Branch( "BeamCal_bcal_e"      , &d.BeamCal_bcal_e      , "BeamCal_bcal_e[nBeamCals]"     );

  
  _evtdata->Branch( "nmcr"            , &d.nmcr            , "nmcr[nBeamCals]/I"         );
  _evtdata->Branch( "mcr_weight"      , &d.mcr_weight      , "mcr_weight[nBeamCals]"     );
  _evtdata->Branch( "mcr_e"           , &d.mcr_e           , "mcr_e[nBeamCals]"          );
  _evtdata->Branch( "mcr_px"          , &d.mcr_px          , "mcr_px[nBeamCals]"         );
  _evtdata->Branch( "mcr_py"          , &d.mcr_py          , "mcr_py[nBeamCals]"         );
  _evtdata->Branch( "mcr_pz"          , &d.mcr_pz          , "mcr_pz[nBeamCals]"         );
  _evtdata->Branch( "mcr_phi"         , &d.mcr_phi         , "mcr_phi[nBeamCals]"        );
  _evtdata->Branch( "mcr_theta"       , &d.mcr_theta       , "mcr_theta[nBeamCals]"      );
  _evtdata->Branch( "mcr_chrg"        , &d.mcr_chrg        , "mcr_chrg[nBeamCals]"       );
  _evtdata->Branch( "mcr_pdg"         , &d.mcr_pdg         , "mcr_pdg[nBeamCals]/I"      );
  _evtdata->Branch( "mcr_genstatus"   , &d.mcr_genstatus   , "mcr_genstatus[nBeamCals]/I");
  _evtdata->Branch( "mcr_simstatus"   , &d.mcr_simstatus   , "mcr_simstatus[nBeamCals]/I");
  _evtdata->Branch( "mcr_iscreatedinsim"   , &d.mcr_iscreatedinsim   , "mcr_iscreatedinsim[nBeamCals]/O");
*/
  _evtdata->Branch( "nmcps"           , &d.nmcps           , "nmcps/I"               );
  _evtdata->Branch( "ipx"             , &d.ipx             , "ipx"                   );
  _evtdata->Branch( "ipy"             , &d.ipy             , "ipy"                   );
  _evtdata->Branch( "ipz"             , &d.ipz             , "ipz"                   );
  _evtdata->Branch( "mcp_index"       , &d.mcp_index       , "mcp_index[nmcps]/I"    );
  _evtdata->Branch( "mcp_e"           , &d.mcp_e           , "mcp_e[nmcps]"          );
  _evtdata->Branch( "mcp_px"          , &d.mcp_px          , "mcp_px[nmcps]"         );
  _evtdata->Branch( "mcp_py"          , &d.mcp_py          , "mcp_py[nmcps]"         );
  _evtdata->Branch( "mcp_pz"          , &d.mcp_pz          , "mcp_pz[nmcps]"         );
  _evtdata->Branch( "mcp_phi"         , &d.mcp_phi         , "mcp_phi[nmcps]"        );
  _evtdata->Branch( "mcp_theta"       , &d.mcp_theta       , "mcp_theta[nmcps]"      );
  _evtdata->Branch( "mcp_chrg"        , &d.mcp_chrg        , "mcp_chrg[nmcps]"       );
  _evtdata->Branch( "mcp_startx"      , &d.mcp_startx      , "mcp_startx[nmcps]"     );
  _evtdata->Branch( "mcp_starty"      , &d.mcp_starty      , "mcp_starty[nmcps]"     );
  _evtdata->Branch( "mcp_startz"      , &d.mcp_startz      , "mcp_startz[nmcps]"     );
  _evtdata->Branch( "mcp_endx"        , &d.mcp_endx        , "mcp_endx[nmcps]"       );
  _evtdata->Branch( "mcp_endy"        , &d.mcp_endy        , "mcp_endy[nmcps]"       );
  _evtdata->Branch( "mcp_endz"        , &d.mcp_endz        , "mcp_endz[nmcps]"       );
  _evtdata->Branch( "mcp_pdg"         , &d.mcp_pdg         , "mcp_pdg[nmcps]/I"      );
  _evtdata->Branch( "mcp_nparents"    , &d.mcp_nparents    , "mcp_nparents[nmcps]/I" );
  _evtdata->Branch( "mcp_parentIndex" , &d.mcp_parentIndex , "mcp_parentIndex[nmcps][10]/I" );
  _evtdata->Branch( "mcp_ndaughters"    , &d.mcp_ndaughters    , "mcp_ndaughters[nmcps]/I" );
  _evtdata->Branch( "mcp_daughterIndex" , &d.mcp_daughterIndex , "mcp_daughterIndex[nmcps][10]/I" );
  _evtdata->Branch( "mcp_genstatus"   , &d.mcp_genstatus   , "mcp_genstatus[nmcps]/I");
  _evtdata->Branch( "mcp_simstatus"   , &d.mcp_simstatus   , "mcp_simstatus[nmcps]/I");
  _evtdata->Branch( "mcp_iscreatedinsim"   , &d.mcp_iscreatedinsim   , "mcp_iscreatedinsim[nmcps]/O");
  _evtdata->Branch( "nclrhits"        , &d.nclrhits        , "nclrhits/I"            );
  _evtdata->Branch( "clr_x"           , &d.clr_x           , "clr_x[nclrhits]"       );
  _evtdata->Branch( "clr_y"           , &d.clr_y           , "clr_y[nclrhits]"       );
  _evtdata->Branch( "clr_z"           , &d.clr_z           , "clr_z[nclrhits]"       );
  return;

}

TVector3 MonoPhotonProcessor::getIP(MCParticle* p) {
  MCParticle* mcp = p;
  while (mcp->getParents().size()) {
    mcp = mcp->getParents()[0];
  }
  TVector3 ip(mcp->getVertex());
  return ip;
}
