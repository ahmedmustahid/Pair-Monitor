#include "MonoPhotonProcessor.h"
#include <iostream>
#include <stdlib.h>

#include <EVENT/LCCollection.h>
#include <EVENT/ReconstructedParticle.h>
#include <EVENT/MCParticle.h>
#include <EVENT/SimCalorimeterHit.h>

#include <UTIL/CellIDDecoder.h>

// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"

#ifdef MARLIN_USE_AIDA
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>

//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

#include "TFile.h"
#include "TTree.h"
#include "TH2D.h"
#include "TMath.h"
#include "TVector3.h"
float bcale=0, mcpe=0;
using namespace lcio ;
using namespace marlin ;


MonoPhotonProcessor aMonoPhotonProcessor ;


MonoPhotonProcessor::MonoPhotonProcessor() : Processor("MonoPhotonProcessor") {

    // modify processor description
    _description = "MonoPhotonProcessor does whatever it does ..." ;


    // register steering parameters: name, description, class-variable, default value
    registerInputCollection( LCIO::MCPARTICLE,
            "MCParticle" , 
            "Name of the MCParticle collection"  ,
            _colMCP ,
            std::string("MCParticle")
    );
    //BeamCalorimeterHit
    registerInputCollection( LCIO::SIMCALORIMETERHIT,
  	   "BeamCalCollection" , 
  	   "Name of the BeamCalHits collection"  ,
  	   _colBeamCal ,
  	   std::string("BeamCalCollection") 
    ) ;

/*
    registerInputCollection( LCIO::LCRELATION,
	   "InputMCTruthLinkCollection" , 
  	   "Name of the MCTruthLink collection"  ,
  	   _colMCBeamCalRelation ,
  	   std::string("RecoMCTruthLink") 
    ) ;
*/
    registerProcessorParameter( "OutputRootFileName",
           "Name of Root file (default: output.root)",
           _rootfilename, 
           std::string("output.root")
    );

}



void MonoPhotonProcessor::init() { 

    streamlog_out(DEBUG) << "   init called  " << std::endl ;

    //std::cout<<"inside init"<<std::endl;

    // usually a good idea to
    printParameters() ;

    TH2D* h = new TH2D("h","",100,-1000,1000,100,-1000,1000);
    _nRun = 0 ;
    _nEvt = 0 ;
//    _navBeamCal = 0;

    makeNTuple();

}


void MonoPhotonProcessor::processRunHeader( LCRunHeader* run) { 
    
    //std::cout<<"inside RunHeader"<<std::endl;
    _nRun++ ;
} 



void MonoPhotonProcessor::processEvent( LCEvent * evt ) { 

    // this gets called for every event 
    // usually the working horse ...

    // Clear memory
    memset( &_data, 0, sizeof(_data) );
    memset( &_stepdata, 0, sizeof(_stepdata) );

    // try to get lcio collection (exits if collection is not available)
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    LCCollection* colmcp = evt->getCollection( _colMCP ) ;
    LCCollection* colBeamCal = evt->getCollection( _colBeamCal ) ;

    int eventnum = evt->getEventNumber() ;
    std::cout<<"eventnum "<<eventnum<<std::endl;
    //if(eventnum>0) exit(EXIT_SUCCESS);

    //LCCollection* colmcBeamCalrel = evt->getCollection( _colMCBeamCalRelation ) ;

    //std::cout<<"inside process event"<<std::endl;
    // Alternativelly if you do not want Marlin to exit in case of a non-existing collection
    // use the following (commented out) code:
    LCCollection* col = NULL;
    try{
        col = evt->getCollection( _colMCP );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colMCP << " collection not available" << std::endl;
        col = NULL;
    }
   
    
    LCCollection* col1 = NULL;
    try{
        col1 = evt->getCollection( _colBeamCal );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colBeamCal << " collection not available" << std::endl;
        col1 = NULL;
    }
    

    
    int nBeamCalstep=0;
    //nBeamCalstep = 45000;
    //_stepdata.nBeamCalstep = nBeamCalstep;

    /* from daniel
    if ( _SimCalorimeterHitDecoder ) delete _SimCalorimeterHitDecoder;
    _SimCalorimeterHitDecoder = new CellIDDecoder<SimCalorimeterHit> (simhitcol);
    for (int j=0; j<simhitcol->getNumberOfElements(); j++) {
      SimCalorimeterHit* simcalhit = dynamic_cast<SimCalorimeterHit*> (simhitcol->getElementAt(j));
      int layer = (*_SimCalorimeterHitDecoder)( simcalhit ) [ "layer" ];
    */


    if( colBeamCal != NULL ){

        int nBeamCal = colBeamCal->getNumberOfElements()  ;
        _data.nBeamCals = nBeamCal;

	    CellIDDecoder<SimCalorimeterHit> decoder(colBeamCal);


        std::cout<<"nBeamCal "<<nBeamCal<<std::endl;


        int icalhits = 0;
        for(int i=0; i< nBeamCal ; i++){
            if(i>NMAX_BeamCalS){
                std::cout<<"Breaking "<<std::endl;
                break;
            }
            //if(i>1000) break;
            SimCalorimeterHit* p = dynamic_cast<SimCalorimeterHit*>( colBeamCal->getElementAt( i ) ) ;

	        int layer = decoder( p ) ["layer"];
	        int phi = decoder( p ) ["phi"];
	        int r = decoder( p ) ["r"];
	        int slice = decoder( p ) ["slice"];

	        std::cout << "layer " << layer << std::endl;
	        std::cout << "r " << r << std::endl;
	        std::cout << "phi " << phi << std::endl;
	        std::cout << "slice " << slice << std::endl;

            _data.BeamCal_z[i]    = p->getPosition()[2];

            _data.BeamCal_nmccont[i] = p->getNMCContributions();

            //std::cout<<"i "<<i<<std::endl;
            //std::cout<<"ncmcont "<<_data.BeamCal_nmccont[i]<<std::endl;
            
            //if(_data.BeamCal_z[i]>3197 && _data.BeamCal_z[i]<3200){
            if(layer==1){
                for(int j=0; j<p->getNMCContributions();j++){
                    //if(j>1){
                    //    break;
                    //}
                    //nBeamCalstep+=1;
                    _stepdata.BeamCal_stepx[j]    = p->getStepPosition(j)[0];
                    _stepdata.BeamCal_stepy[j]    = p->getStepPosition(j)[1];
                    _stepdata.BeamCal_stepz[j]    = p->getStepPosition(j)[2];
                    _stepdata.BeamCal_energycont[j] = p->getEnergyCont(j);
                    _stepdata.BeamCal_timecont[j]   = p->getTimeCont(j);
                    _stepdata.BeamCal_pdgcont[j]    = p->getPDGCont(j);

                    _stepdata.nBeamCalstep = p->getNMCContributions();
                    //h->Fill(_stepdata.BeamCal_stepx,_stepdata.BeamCal_stepy);
                    std::cout<<"j "<<j<<std::endl;
                    //std::cout<<"pdgcont "<<_stepdata.BeamCal_pdgcont[j]<<std::endl;

                }

            }
            //}


        _evtdata_step->Fill();
        }
        _data.nclrhits = icalhits;
    }
    std::cout<<"nBeamCalstep "<<nBeamCalstep<<std::endl;
    streamlog_out(DEBUG) << "   processing event: " << evt->getEventNumber() 
    << "   in run:  " << evt->getRunNumber() << std::endl ;
    _data.evt = _nEvt;
    _evtdata->Fill(); 
    _nEvt ++ ;

}

    



    //_data.evt = _nEvt;

    //_evtdata->Fill(); 

    //_nEvt ++ ;


void MonoPhotonProcessor::check( LCEvent * evt ) { 
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void MonoPhotonProcessor::end(){ 

    _otfile->Write();
    //if(_nEvt> 0) exit(EXIT_SUCCESS); 
    //h->Write();
    std::cout << "MonoPhotonProcessor::end()  " << name() 
    << " processed " << _nEvt << " events in " << _nRun << " runs "
    << std::endl ;

    //std::cout<< "mcpe "<<mcpe<<std::endl;
    //std::cout<< "bcale "<<bcale<<std::endl;

}

void MonoPhotonProcessor::makeNTuple() {

    // Output root file
    _otfile    = new TFile( _rootfilename.c_str() , "RECREATE" );
    
    EVTFILLDATA &d = _data;
    EVTFILLSTEPDATA &stepd = _stepdata;
    
    /** Define root tree
    */
    _evtdata  = new TTree( "evtdata" , "events" );
    _evtdata_step  = new TTree( "evtdata_step" , "events" );

    
    _evtdata->Branch( "nBeamCals"           , &d.nBeamCals           , "nBeamCals/I"         );
    _evtdata->Branch( "BeamCal_z"          , &d.BeamCal_z          , "BeamCal_z[nBeamCals]"         );
    _evtdata->Branch(  "BeamCal_nmccont   " , &d.BeamCal_nmccont   ,"BeamCal_nmccont[nBeamCals]/I    "  ) ;   
    
    _evtdata_step->Branch( "nBeamCalstep"           , &stepd.nBeamCalstep           , "nBeamCalstep/I"                      );
    _evtdata_step->Branch( "BeamCal_stepx"          , stepd.BeamCal_stepx          , "BeamCal_stepx[nBeamCalstep]"         );
    _evtdata_step->Branch( "BeamCal_stepy"          , stepd.BeamCal_stepy          , "BeamCal_stepy[nBeamCalstep]"         );
    _evtdata_step->Branch( "BeamCal_stepz"          , stepd.BeamCal_stepz          , "BeamCal_stepz[nBeamCalstep]"         );
    _evtdata_step->Branch(  "BeamCal_energycont" , stepd.BeamCal_energycont        ,"BeamCal_energycont[nBeamCalstep] "    );
    _evtdata_step->Branch(  "BeamCal_timecont  " , stepd.BeamCal_timecont          ,"BeamCal_timecont[nBeamCalstep]   "    );
    _evtdata_step->Branch(  "BeamCal_pdgcont   " , stepd.BeamCal_pdgcont           ,"BeamCal_pdgcont[nBeamCalstep]    "    );
    
}

TVector3 MonoPhotonProcessor::getIP(MCParticle* p) {
  MCParticle* mcp = p;
  while (mcp->getParents().size()) {
    mcp = mcp->getParents()[0];
  }
  TVector3 ip(mcp->getVertex());
  return ip;
}
